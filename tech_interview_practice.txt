# 	Practice Problems from Jumpstart
# 	(for technical interview practice)















# Remove Duplicates
# (jumpstart lecture problem)

# given a string, remove all duplicates
# cannot use unique method
# unique_letters("abcccdeaf") -> "abcdef"
#
# def unique_letters(str)
#   results = ""
#   i = 0
#   while i < str.length
#     # if !results.include?(str[i])
#     #   results+=str[i]
#     # end
#     results << str[i] unless results.include?(str[i])
#     i+=1
#   end
#   return results
# end
# # puts "unique_letters"
# p unique_letters("abcccdeaf")














# Third Largest
# (jumpstart lecture problem)

# Given an array of values return the third largest value.

# def third_largest_number(arr)
  #iterate thru array
  #set value of biggest
  #compare if its biggest
    #if bigger, set biggest to new one
    #2nd biggest is now the prev biggest
    #comapre for the third

#   # 2
#   # [1,5,6]
#   results = Array.new(3){ -1 }
#   # results = [arr[0],arr[1],arr[2]].sort
#   i = 0
#   while i < arr.length
#     if arr[i] > results[-1]
#         results.push(arr[i]).shift
#       # results[-1] = arr[i]
#     elsif arr[i] > results[-2]
#         results[0] = results[1]
#         results[1] = arr[i]
#     elsif arr[i] > results[0]
#         results[0] = arr[i]
#     end
#     i+=1
#   end
#   results[0]
#   # p arr.sort
#   # arr.sort[-3]
# end

# puts "third largest number\n"
# p third_largest_number([6,7,8,9,10,1,2,3,4,5])














# Double Array Sort
# (jumpstart lecture problem)

# given 2 sorted arrays
# return combined arrays sorted
# no .sort
# def merge_sorted_arrays(arr1,arr2)
#   results = []

#   while arr1.length > 0 and arr2.length > 0
#     if arr1[0] > arr2[0]
#       results << arr2.shift
#     else
#       results << arr1.shift
#     end
#   #compare first element of each array
#     #shift that array and add to results
#   #continue until one array is empty
#   end

#   # if arr1.length == 0
#   #   results+=arr2
#   # else
#   #   results+=arr1
#   # end

#   #add all the remaining elements to results
#   return results + arr1 + arr2
# end














# Merge Sorted Arrays
# (jumpstart lecture problem)

# # puts "merge_sorted_arrays\n"
# p merge_sorted_arrays([1,2,4],[3,6,10,11]) == [1,2,4,3,6,10,11].sort

# # given a sorted array with no duplicates
# # return the index of where the value is
# # if the value doesn't exist, return the index
# # where the number would be

# # search_insert([1,3,5,6],5) -> 2
# # search_insert([1,3,5,6],2) -> 1
# # search_insert([1,3,5,6],0) -> 0
# # search_insert([1,3,5,6],8) -> 4
# # puts "======================"
# def search_insert(arr,value)

# end

# # puts "search_insert\n"
# # p search_insert([1,3,5,6],5) 
# # p search_insert([1,3,5,6],2) 
# # p search_insert([1,3,5,6],0) 
# # p search_insert([1,3,5,6],8)














# Titleize
# (jumpstart lecture problem)

# #
# # Write a method that capitalizes each word in a string like a book title.
# # Do not capitalize words like 'a', 'and', 'of', 'over' or 'the'.

# def titleize(title)

# end

# # puts "-------Titleize-------"
# # puts titleize("basketball") == "Basketball"
# # puts titleize("stephen curry") == "Stephen Curry"
# # puts titleize("war and peace") == "War and Peace"
# # puts titleize("the bridge over the river kwai") == "The Bridge over the River Kwai"














# Reverse Integer
# (jumpstart lecture problem)

# def reverse_integer(number)
#     # easy mode
#     # number.to_s.reverse.to_i
# â€‹
#     # hard mode
#     arr = []
#     # grab digit from ones place and store into array
#     current_num = number
#     while current_num >= 10
#         # shift number and repeat until value is less than 10
#         arr.unshift(current_num%10)
#         current_num/=10
#     end
#     # store that value when less than 10
#     arr.unshift(current_num)
#     sum = 0
#     # add up the sum and return it
#     arr.each_with_index do |el,i|
#         sum+= (el*10**i)
#     end
#     return sum
# end














# Possible Pairs
# (jumpstart lecture problem)

# def possible_pairs(arr)
#   results = []
#   arr.each_with_index do |el1,idx1|
#     arr.each_with_index do |el2,idx2|
#      puts "element1 #{el1} at index1 #{idx1}"
#       puts "element2 #{el2} at index2 #{idx2}"
#       if idx1 != idx2
#         results << [el1,el2]
#       end
#     end
#   end
#   results
# end

# p possible_pairs([1,2,3])
# puts "###########################################\n\n"
# def possible_uniq_pairs(arr)
#   results = []
#   (0...arr.length-1).each do |i|
#     (i...arr.length).each do |j|
#       temp = []
#       if (i != j)
#         if arr[i] > arr[j]
#           temp << arr[j] << arr[i]
#         else
#           temp << arr[i] << arr[j]
#         end
#         p temp
#         p "results is #{results}"
#         if !(results.include?(temp))
#           results << temp
#         end
#       end
#     end
#   end
#   results
# end

# p possible_uniq_pairs([1,2,3])
# puts "\n\n###########################################\n\n"
# 2D arrays

# index














# 2D Array Print
# (jumpstart lecture problem)

# arr = [[1,2,3],
#         [7,8,9,10],
#         [4,5,6],
#         [7,8,9]]
# p arr[0][1]
# p [1,2,3][1]
# p arr[0][0] # 1
# p arr[0,0] #don't do this.don't use commas beginners do this
# p arr[1][1] # 5
# puts "\n\n###########################################\n\n"
# iterate through 2D arrays

# One way
# arr.each do |array| #array
#   array.each do |value|
#     puts value
#   end
# end

# puts "\n\n###########################################\n\n"
# Another
# arr.length.times do |el|
#   arr[el].length.times do |value|
#     puts value
#   end
# end

# i = 0
# while i < arr.length
#   j = 0
#   while j < arr[i].length
#     puts arr[i][j]
#     j+=1
#   end
#   i+=1
# end

#this is usually for iterating through all pairs of one array
# i = 0
# while i < arr.length
#   j = i
#   while j < arr[i].length


#     j+=1
#   end
#   i+=1
# end














# Pair Product

# Define a method, #pair_product?, that accepts two arguments: an array of
# integers and a target_product (an integer). The method returns a boolean
# indicating whether any pair of elements in the array multiplied together equals
# that product. You cannot multiply an element by itself. An element on its
# own is not a product.
# pair_product?([3, 1, 5], 15) => true because 3*5 == 15

# def pair_product?(arr, target_product)
#   arr[0...-1].each_with_index do |num1,i1|
#     arr[i1+1..-1].each_with_index do |num2,i2|
#       # if i2 > i1
#         return true if num1*num2==target_product
#       # end
#     end
#   end
#   return false
# end
# puts "pair product"
# p pair_product?([3,6,8,1, 5], 15)
# puts "\n\n###########################################\n\n"














# Given a string, return the longest palindrome
# (jumpstart whiteboard problem)

# def longest_palindrome(str)
#   #need to check if a str reversed is the same as the string  
#   current_longest = ""
#   i = 0

#   #str[0..-2].each_char.with_index do |el,i|
#   while i < str.length-1
#     j = i+1
#     #str[i+1..-1].each_char.with_index do |el2,j|
#     while j < str.length
#       if str[i..j] == str[i..j].reverse
#         if current_longest.length < str[i..j].length
#           current_longest = str[i..j]
#         end
#       end
#       j+=1
#     end
#     i+=1
#   end

#   return current_longest
# end

# puts "longest palindrome"
# p longest_palindrome("abracadabra") # aca
# p longest_palindrome("HYTBCABADEFGHABCDEDCBAGHTFYW12345678987654321ZWETYGDE") # 12345678987654321














# Letter Swap
# (jumpstart whiteboard problem)

# You are given a sentence and an array of 2 letters

# Write a method that will return the sentence with any instance of
# the first letter switched with the second letter and vice versa.
# It should treat capitalized or lowercase letters the same.


# def swap_letters(sentence, letters)
#   swapped = ""
#   #nested loop

#   #iterate thru sentence
#   sentence.each_char.with_index do |ch,i|
#     #loop through letters
#     swap = false
#     letters.each_with_index do |letter,j|
#       if letter == ch.downcase
#         swapped+= letters[(j+1)%2]
#         swap = true
#       end
#     end
#     if swap == false
#       swapped+=ch
#     end
#       #if either character match downcased
#         # redefine to the other letter, add to swapped
#       #else
#         # add to swapped
#   end
#   return swapped
# end

# # puts "-------Letter Swap--------"
# puts swap_letters("I went to the dentist", ["n", "t"]) #== "I wetn no nhe detnisn"
# puts swap_letters("I went to the dentist", ["t", "n"]) #== "I wetn no nhe detnisn"
# puts swap_letters("My name is Michael", ["a", "m"])# == "ay nmae is aichmel"














# Tic Tac Toe
# (jumpstart lecture problem)

# might be super hard, but let's try anyway!
# game won't be playable, but will check for things
# this is your chance to apply nested loops in action!

# test= [["X","X","O"],[" ", " ", " "],[" ", " ", " "]]
# test_tie= [["O","X","O"],["O","X","O"],["X","O","X"]]
# test_x_wins= [["X","X","O"],["X","O", "O"],["X", " ", " "]]
# bad_test1 = [[" ", " ", " "],["Z","X","O"],[" ", " ", " "]]
# bad_test2 = [[],[],[],[]]
# empty_board = [[" ", " ", " "],[" "," "," "],[" ", " ", " "]]
# test_o_wins = [["O","X","O"],["X","O", "O"],["X", " ", "O"]]

# should check if a board is valid, output it nicely
# check if there's a winner
# def tic_tac_toe(board = Array.new(3){ Array.new(3) { " " }})

# end

# determines if this is a valid board, must contain either X, O or a white space
# def valid_board?(board)

# end
# puts "valid board test"
# puts "should be false false true"
# p valid_board?(bad_test1)
# p valid_board?(bad_test2)
# p valid_board?(test)
# puts "##############"


# how do i actually output the board

# X | X | O 
# -----------
# X | O | O 
# -----------
# X |   |   

# 11 -

# def display_game(board)

# end
# test_x_wins= [["X","X","O"],
              # ["X","O", "O"],
              # ["X", " ", " "]]


# def winner(board)
 
# end

# p winner(test_x_wins)
# p winner(test_o_wins)
# p winner(test_tie)
# tic_tac_toe(test_x_wins)














# Transpose Array
# (jumpstart whiteboard problem)

# transpose / rotate a 2D array














# Reverse Integer
# (jumpstart whiteboard problem)

# reverse a multi-digit integer, returning an integer














# Prime Skip
# (jumpstart whiteboard problem)

# Take in an integer, return the first two consecutive prime numbers that have a difference of the input number.














# Flip Match
# (jumpstart whiteboard problem)

# Take in two strings of four charactors and return a boolean indicating whether or not.
# Flipping the odd or even charactors in either string could make them match.














# Count Vowels

# Write a method, count_vowels(word), that takes in a string word and returns the number of vowels in the word. Vowels are the letters a, e, i, o, u.

# def vowel_count(word)
#   count = 0
#   i = 0
#   while i < word.length
#     if word[i] == "a" || word[i] == "e" || word[i] == "i" || word[i] == "o" || word[i] == "u"
#       count += 1
#     end
#     i += 1
#   end
#   return count
# end

# puts vowel_count("hello")














# Is Palindrome

# Write a method is_palindrome(word) that takes in a string word and returns the true if the word is a palindrome, false otherwise. A palindrome is a word that is spelled the same forwards and backwards.

# def is_pal(word)
#   pal = ""
#   i = 0
#   while i < word.length
#     pal = word[i] + pal
#     i += 1
#   end
#   return pal == word
# end

# puts is_pal("kayak")



# def sum_of_a_beach(str)
# count = 0
# i = 0
# while i < str.length
# if str[i..i+3].downcase == "sand"
# count += 1
# elsif str[i..i+3].downcase == "fish"
# count += 1
# elsif str[i..i+4].downcase == "water"
# count += 1
# elsif str[i..i+2].downcase == "sun"
# count += 1
# end
# i += 1
# end
# count
# end				     

# print sum_of_a_beach("WAtErSlIde")
# print sum_of_a_beach("GolDeNSanDyWateRyBeaChSuNN")
# print sum_of_a_beach("gOfIshsunesunFiSh")
# print sum_of_a_beach("cItYTowNcARShoW")














# Is Triangle

# Given three integers determine if a triangle can be made. Return boolean.
# def isRightTriangle(a,b,c)
#   # a = a ** 2
#   # b = b ** 2
#   # c = c ** 2
#   if ((a ** 2) + (b ** 2) == (c ** 2)) || ((a ** 2) + (c ** 2) == (b ** 2)) || ((b ** 2) + (c ** 2) == (a ** 2))
#     return true 
#   end
#   return false
# end
# puts isRightTriangle(2,2,4)


# def isTriangle(a,b,c)
#   if ((a + b) < c) || ((a + c) < b) || ((b + c) < a)
#     return false
#   else
#     return true
#   end
#   # a triangle cannot have a length greater than the sum of the other two lengths?
#   # not working.... ::(( too much sake...
# end
# puts 5 || 1
# puts isTriangle(2,2,4)


# def makeHypo(sideA, sideB)
#   return Math.sqrt(sideA ** 2 + sideB ** 2)
# end
# >> (2.3465*100).round / 100.0
# => 2.35
# puts makeHypo(1,2)














# Missing Intigers 
# (Youtube Sample A/a Tecnical Interview)

# create a function that takes an array of ordered integers that form an
# incomplete consecutive set and returns an array of integers
# that are missing from from this consecutive set

# def missing_nums(arr)
# create a new empty array
# loop from first to last number (NOT index) in input array
# if iteration number is present in input array then do nothing
# otherwise add iteration number to new array
# return new array

  # new_arr = []
  # (arr.first..arr.last).each { |num| new_arr.push(num) if !arr.include?(num) }
  # new_arr

  # new_arr = []
  # i = arr[0]
  # while i < arr[-1]
  #   new_arr << i if !arr.include?(i)
  #   i += 1
  # end
  # new_arr
# end

# print missing_nums([1,3]) # => [2]
# print missing_nums([0,5,7]) # => [1,2,3,4,6]
# print missing_nums([-3,0,1,2,5]) # => [-2,-1,3,4]














# Broken Key
# (Youtube Sample A/a Tecnical Interview)


# Write a method that takes two strings, a sequence and a key. 
# The method should return true if all the individual charactors in the key string
# appear in order in the sequence string, but not necessarily contiquously. 
# If the key charactors appear out of order or some are absent in
# the sequence then the method should return false.

# loop through each charactor in the key...
# loop through each charactor in the sequence
# if a key charactor matches a sequence charactor then iterate the key loop and keep our place in the sequence loop
# else return false
# if loops complete without triggering a false return..
# then return true


# def key_search(sequence, key)
#   seq_idx = 0
#   key_idx = 0
#   while key_idx < key.length
#     if key(key_idx) == sequence[seq_idx]
#       seq_idx += 1
#       key_idx += 1
#     elsif seq_idx > sequence.length
#       return false
#     else
#       key_idx += 1
#     end
#   end
#   true
# end

# puts key_search("cuautonj", "cat") # => true
# puts key_search("tac", "cat") # => false














# Find Last Charactor
# (Youtube Sample A/a Tecnical Interview)


# def last_index(str, char)
# # loop through input string from end to beginning (backwards)
# # check to see if a given character is equal to input char
# # once found, determine the index based on the string's length
# # return an integer representing the last index at which the character is found in the string

# i = str.length - 1
# while i >= 0
# return i if str[i] == char
# i -= 1
# end
# end

# puts last_index("abca", "a")#=> 3
# puts last_index("mississipi", "i")#=> 9
# puts last_index("octagon", "o")#=> 5
# puts last_index("programming", "m")#=> 7
# puts last_index("gon", "o")#=> 1














# Pick Primes

# Write a method pick_primes that takes in an array of numbers and returns a new array containing only the prime numbers.

# def is_prime(num)
# # return true or false

# i = num - 1
#   while i > 1
#     if num % i == 0
#       return false
#     end
#     i -= 1
#   end
#   true
# end

# def pick_primes(arr)
# # create an empty array
# # loop over our input array
# # if a given number is only divisible by itself and one...
# # then add it to our new array
# # return an array containing only the prime numbers from the input array

#   new_arr = []
#   i = 0
#   while i < arr.length
#     new_arr << arr[i] if is_prime(arr[i])
#     i += 1
#   end
# end

# print pick_primes([2, 3, 4, 5, 6])#=>[2, 3, 5]
# puts
# print pick_primes([101, 20, 103, 2017])#=>[101, 103, 2017]
# puts
# print pick_primes([3, 4])#=>[3]
# puts














# Josephus Survivor
# (jumpstart whiteboard problem)

##### AJ's SOLUTION

# def josephus_survivor(n, k)
#   # delete item at arr[(k - 1) % arr.length]
#   # delete item at (last + k - 1) % arr.length
#   # fill items in new arr
  
#   arr = Array (1..n)
#   curr = (k - 1) % arr.length
#   until arr.length == 1
#     arr.delete_at(curr)
#     curr = (curr + k - 1) % arr.length
#   end
#   arr[0]
# end

# josephus_survivor(n, k)














# Longest Palindrome

# def longest_palindrome(str)
  # make a state array that accounts for str(1...-1)
  # make placeholder var for longest palindrome
  # loop through states

# end














# Move Zeros
# (jumpstart whiteboard problem)

# Move all zeros to the end of the array in place

# def move_zeros(arr)
#   length = arr.length 

# end














# Roman Numerals
# (jumpstart whiteboard problem)

# def roman_to_int(s)
#   #make a hash
#   symbols = {
#     "I"=>1,
#     "V"=>5,
#     "X"=>10,
#     "L"=>50,
#     "C"=>100,
#     "D"=>500,
#     "M"=>1000
#   }
#   #return a sum, int
#   sum = 0
#   i = 0
#   while i < s.length
#     if i == s.length-1
#       sum += symbols[s[i]] 
#     elsif symbols[s[i+1]] > symbols[s[i]] 
#       sum -= symbols[s[i]] 
#     else
#       sum += symbols[s[i]] 
#     end
#     i+=1
#   end
#   #iterate through each character in string
#   return sum
# end
# p roman_to_int("MMMCIV") #3104
# p roman_to_int("X")
# p roman_to_int("XV")
# p roman_to_int("IX")
# p roman_to_int("XI")
# p roman_to_int("XX")
